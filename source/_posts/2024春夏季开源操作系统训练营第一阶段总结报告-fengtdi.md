---
title: 2024春夏季开源操作系统训练营第一阶段总结报告-fengtdi
date: 2024-04-24 21:38:58
tags:
    - author:zlh20040308
---  

# 2024春夏季开源操作系统训练营第一阶段总结报告  

## 前言  

了解到这个训练营源自一次机缘巧合，刚学完操作系统的鄙人在b站刷课时无意刷到了前训练营的导学部分，并在评论区看到了up主留下的链接，点进去一看正好都是我很感兴趣的方向，而且学习资源和github页面都整理得很完善，于是果断加入了  

## Rust编程基础  

### 初探

第一阶段的的主要任务是学习Rust语言，刚接触这门语言时候的第一感觉就是概念十分的多，有些概念甚至看起来匪夷所思，如生命周期标注，我十分不理解为什么Rust要这么设计，但是秉持着能跑就行的原则，还是硬着头皮和编译器作斗争  

### 初窥门径

带着以上这些问题，我找到了斯坦福大学CS110L这门课，这门课并不是教学生如何进行Rust编程，而是希望通过Rust的视角反映出当今两种主流内存分配机制——手动管理（malloc&free）和垃圾回收（GC）——的不足，在其三节课就主要讨论了它们所会遇到的问题：  

- 手动管理（C/C++）  

    C/C++的类型系统对内存所有权的表达能力是十分有限的，以至于工程师在设计函数接口时会显得十分臃肿，还必须附上大量的注释来告知调用者去担负起管理内存的责任，也就是说内存的管理取决于程序员的自觉性，这就导致程序员经常会忘记之前申请过释放内存，而且随着工程的不断壮大，这种错误会不可避免地发生  

- 垃圾回收（Java）  

    Java通过某种类似于引用计数的方式来自动回收内存，但这种设计会带来性能上的损耗（回收机制过于复杂）  

而Rust便带来了属于它的第三种方案，那就是**所有权机制**，在这种机制下，内存管理会变得高效且安全，这得益于它强大的静态检测机制，能够在编译时期就规避掉很多内存泄露的隐患  

但这也是有代价的，既然要求在编译时期就能发现错误，那么Rust编译器就会要求程序员在编码时附带足够多的信息供它推断，也就出现了类似于生命周期标注这些语法  

### 牛刀小试  

在初步过完几轮Rust基础并完成了rustlings之后，便开始着手用Rust复刻了一些之前写过的小项目（当然，还有那令Rust新手望而生畏的链表），在这段过程中越发能感受到Rust的一些设计理念在影响着我的编码习惯，也引起了我对与内存安全的思考  

### 总结  

在经历了这一阶段的学习后，虽然我到现在也不认为我是一个Rust程序员，但是也多多少少能用Rust去进行一些有效编码了  

十分感谢第一阶段中为我答疑解惑的老师和同学，同时更要感谢开源操作系统训练营提供了这么一个平台把大家聚集在了一起，我十分喜欢这里的学习氛围，大家一起交流着学习上的疑惑并提出自己的见解，这开源的理念也使我收益颇丰

