---
title:2024年开源操作系统训练营第一阶段学习总结-卓堂越
date: 2024-04-28 08:44:54
categories:
    - 2024春夏季开源操作系统训练营 
tags:
    - author:nusakom
    - repo:https://github.com/LearningOS/rust-rustlings-2024-spring-nusakom.git
---
---

2024年开源操作系统训练营第一阶段学习总结-卓堂越
首先，我要衷心感谢所有给予我帮助助教导师。每次我有困惑的时候他们的专业知识和耐心指导帮我解决一系列棘手的问题。通过这个平台可以很好的交到对这方面感兴趣的朋友，在群里跟朋友们讨论让我可以更好地理解和应用 Rust 语法。此外，也离不开Rust 社区分享的宝贵的学习资料。同时课堂上分享的The Rust Reference 不失为一本经典巨作给我前期的语法学习提供很有力的帮助。
在开始开发操作系统之前，先熟悉 Rust 语言的基础知识，包括语法、类型系统、所有权和生命周期等概念为首要目标。选择Rust是因为他的安全性和性能使其成为编写操作系统的理想选择。在正式做练习之前花了很多时间在环境配置上面，之前学过的harmony os 都是他们给的镜像直接导入，第一次在上面搭建问了很多导师问题，他们都耐心的回答我，让我在这方面更有兴趣。比如在当推送本地更改时，如果远程仓库已经有了更新，可能会出现合并冲突，需要手动解决这些冲突。通过这些学习能更好的完成后面几个阶段的学习。
和其他语言对比在生命周期这个方面Rust 强制使用生命周期来检查引用的有效性，以避免悬空引用和数据竞争。生命周期注解使得 Rust 的借用系统变得更加严格和安全。C++ 中也有生命周期的概念，但它通常通过使用智能指针、RAII（资源获取即初始化）等技术。相比rust在这方面更不容易出错。而且在所有权上面Rust 引入了所有权和借用的概念，这是与 C++ 最明显的区别之一。在 Rust 中，每个值都有一个所有者，并且在任何时候只能有一个可变借用或任意数量的不可变借用。这确保了在编译时不会出现数据竞争。在以前学过的 C++ 中，没有类似的所有权和借用系统，开发人员需要手动管理内存和资源，这可能导致内存泄漏、悬空指针和其他常见的错误
fn main() {
    let result;
    {
        let x = 5;
        result = compute(&x);
    }
    println!("Result: {}", result);
}

fn compute<'a>(value: &'a i32) -> &'a i32 {
    value
}
有一个 main 函数，它调用了一个 compute 函数来计算一个整数的引用，并将结果赋值给 result 变量。然后我们尝试在 main 函数中打印 result 的值。然而，compute 函数返回了一个指向局部变量 x 的引用，而 x 的生命周期只在包含它的代码块内有效。由于 x 在 compute 函数返回后就会被销毁，所以返回的引用将指向无效的内存，导致悬垂引用错误。后期我发现需要通过修改函数签名来指定一个更长的生命周期，或者避免返回对局部变量的引用
fn main() {
    let result;
    {
        let x = 5;
        result = compute(x);
    }
    println!("Result: {}", result);
}

fn compute(value: i32) -> i32 {
    value
}
通过上面代码的修改这样就避免了使用引用并返回了整数值本身，从而避免了悬垂引用错误。